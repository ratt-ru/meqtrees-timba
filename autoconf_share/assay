#!/bin/sh
#
# assay: Invoke a test program and verify its output
#
#  Copyright (C) 2001
#  ASTRON (Netherlands Foundation for Research in Astronomy)
#  P.O.Box 2, 7990 AA Dwingeloo, The Netherlands, seg@astron.nl
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#  $Id$


#-----------------------------------------------------------------------------
# Usage: assay <testexe> <max run-time(sec)> <precision> [<arguments>]
#-----------------------------------------------------------------------------
# This script is an adapted version of the AIPS++ assay script.
#
# assay invokes a test program. If the test program has an associated
# .run file then it simply invokes it. Otherwise assay invokes the test
# executable directly.
#
# assay redirects the output of program or .run file to a temporary file
# and compare it with a corresponding .out file (if there) using diff.
# Parts of the output can be skipped using special markers (>>> and <<<).
# If the out files are different, it tries to find out if they match
# by comparing numbers with the given precision (e.g. 1e-5) using:
#    abs(a1-a2) <= precision * max(abs(a1),abs(a2))
#
# example:
#
# >>>
# This total line will be skipped
# <<<
#
# Only >>>this<<< will be skipped 
#
#
#
# A .run file is necessary in the following cases:
# 1. There are other input files. In that case the .run file should
#    copy those files to the working directory. If needed, it should
#    guard against the case where the working directory is already the
#    directory containing the input files.
# 2. There are multiple output files that should be compared.
# 3. The test program has to be run multiple times with various arguments.
# Note that the .run file can be executed from the source directory
# or from the machine/test directory.
#
# An example t_fft.run file could look like:
#
#  #!/bin/sh
#
#  # Get working directory.
#  wdir=`pwd`
#  # Get source directory (by removing trailing part like /dop08/test).
#  sdir=`pwd | sed 's#/[^/]*/test$##'`
#  echo $wdir
#  echo $sdir
#  # Copy input files (actually, guard is not needed in this case).
#  if [ "$wdir" != "$sdir/BASELINE" ]
#  then
#    cp $sdir/BASELINE/*.coef .
#  fi
#  # Execute the program.
#  t_fft
#  STATUS=$?
#  if [ $STATUS ]
#  then
#    # Do a difference of all output files.
#    mdiff *.out $sdir/BASELINE
#    STATUS=$?
#  fi
#  # Remove the files created.
#  if [ "$wdir" != "$sdir/BASELINE" ]
#  then
#    \rm -f  *.coef
#  fi
#  # Remove .out files only if succesfully ended.
#  if [ $STATUS ]
#  then
#    \rm -f *.out*
#  fi
#  exit $STATUS
##########################################################
#
# Options:
#   none
#
# Status returns:
#    0:  success
#    1:  test execution failed
#    2:  test output disagreement
#   77:  untested (conforming make check) (3 is returned from a .run)
#  130:  interrupt
#
# Notes:
#    1) It is assumed that the test executable exists in the working directory.
#
# Original: 1995/11/01 by Mark Calabretta, ATNF
#
#=============================================================================

# CHECKTOOL is a Make option that contains the checktoolcommand. To be able to 
# insert the program name into the options (for logfile naming for example)
# a [PROGNAME] can be inserted into the call, this will be substituted by the
# program name.
#
# For example:
#  make check CHECKTOOL='valgrind --tool=memcheck \
#                                 --num-callers=50 \
#                                 --workaround-gcc296-bugs=yes \
#                                 --leak-check=yes \
#                                 --track-fds=yes \
#                                 --logfile=[PROGNAME]_valgrind'

  if test $# -lt 3; then
    echo "usage: assay <testexe> <max run-time(sec)> <precision> [<arguments>]"
    exit 1
  fi

  PROG=$1
  shift
  MAXTIME=$1
  shift
  PREC=$1
  shift

# Use LimitExec if available
  if [ -x $LOFARROOT/bin/LimitExec ]
  then
    CMDPREFIX="$LOFARROOT/bin/LimitExec $MAXTIME"
  elif [ -x $lofar_sharedir/limitexec.sh ]
  then
    CMDPREFIX="$lofar_sharedir/limitexec.sh $MAXTIME"
  fi
  
  if [ "x$CHECKTOOL" != "x" ]
  then
    CHKTOOL=`echo "$CHECKTOOL" | sed -e 's/\[PROGNAME\]/'$PROG'/g'`
  fi

# Initialize the command to be executed.
  COMMAND="$CMDPREFIX ./$PROG"
  CHECKTOOLCOMMAND="$CHKTOOL ./$PROG"


# Define exit and interrupt handler.
  trap 'rm -rf core ${PROG}_tmp* ; \
        trap 0 ; \
        exit $STATUS' 0 1 2 3 15

# If there is a .run file then use it.
  if [ -f "$PROG.run" ]
  then
     COMMAND="./$PROG.run"
     LOFAR_CHECKTOOL="$CHKTOOL"
     export LOFAR_CHECKTOOL
     CHECKTOOLCOMMAND="./$PROG.run"
  fi

# Determine if this program also needs another checktool check.
# (like valgrind for example)
# Check for the variable name CHECKTOOLPROGS in Makefile.
# that variable should contain the programs that need to be run through 
# an extra checktool that has been supplied via the CHECKTOOL line in Make
  match=`cat Makefile |awk '/CHECKTOOLPROGS/,/ENDCHECKTOOLPROGS/ {print $0}'|grep -v '#'| grep -w $PROG`

  if [ "x$CHECKTOOL" != "x" ]
  then
    if [ "x$match" != "x" ] 
    then
      eval "$CHECKTOOLCOMMAND" > /dev/null
    fi
  fi

# Execute the command.
  if eval "$COMMAND" > ${PROG}_tmp.out
  then
     if [ -f $PROG.out ]
     then
        CAT=cat
     else
        echo "PASS (execution succeeded): $PROG"
        STATUS=0
        exit
     fi
  else
     STATUS=$?
     if [ $STATUS = 3 ]
     then
        echo "UNTESTED: $PROG"
        STATUS=77
     else
        echo "FAIL (execution failure): $PROG"
        # We may want to know what went wrong, so we'll secure the log file
        if [ -f ${PROG}_tmp.log ]
        then
           mv ${PROG}_tmp.log ${PROG}.err
        fi
     fi
     exit
  fi

  echo "Comparing output with $PROG.out ..."
# Strip out demarked text.
# inline parts enclosed by >>> && <<<
  sed -e 's/>>>.*<<<//' ${PROG}_tmp.out > ${PROG}_tmp.out2
# lines enclosed by >>> && <<<
  sed -e '/^>>>/,/^<<</d' ${PROG}_tmp.out2 > ${PROG}_tmp.out

# Compare with the expected output.
  $CAT $PROG.out | sed -e 's/>>>.*<<<//' | sed -e '/^>>>/,/^<<</d' > ${PROG}_tmp_orig.out
  if diff ${PROG}_tmp.out ${PROG}_tmp_orig.out
  then
     echo "PASS (output verified): $PROG"
     STATUS=0
     exit
  fi

# Not fully equal, check if equal except for numbers.
# Replace for this purpose all numbers by x.
  sed -e 's/[+-]\?\(\(\([0-9]\+\)\|\([0-9]*\.\?[0-9]*\)\)\(e[+-]\?[0-9]\+\)\?\)/x/g' ${PROG}_tmp.out > ${PROG}_tmp.out2
  sed -e 's/[+-]\?\(\(\([0-9]\+\)\|\([0-9]*\.\?[0-9]*\)\)\(e[+-]\?[0-9]\+\)\?\)/x/g' ${PROG}_tmp_orig.out > ${PROG}_tmp_orig.out2
  diff ${PROG}_tmp.out2 ${PROG}_tmp_orig.out2 > /dev/null 2>&1
  if [ $? != 0 ]
  then
     echo "FAIL (output not verified): $PROG"
     STATUS=2
     exit
  fi

# Okay, the non-numbers are equal.
# Now check if all numbers are approximately equal.
# First replace all non-numeric characters and single e.+- by a blank.
# Remove blanks by a newline.
  sed -e 's/[^-+.e0-9]/ /g' ${PROG}_tmp.out | sed -e 's/\(^\| \)[e.+-]\+\( \|$\)//g' | sed -e 's/^ \+//' -e 's/ \+$//' -e 's/ \+/\n/g' > ${PROG}_tmp.out2
sed -e 's/[^-+.e0-9]/ /g' ${PROG}_tmp_orig.out | sed -e 's/\(^\| \)[e.+-]\+\( \|$\)//g' | sed -e 's/^ \+//' -e 's/ \+$//' -e 's/ \+/\n/g' > ${PROG}_tmp_orig.out2
# Show the differences column-wise.
  diff -y --suppress-common-lines ${PROG}_tmp.out2 ${PROG}_tmp_orig.out2 > ${PROG}_tmp_diff.out

# Now loop through all differences and see if almost equal.
  awk '{ a1=$1; if (a1<0) a1=-a1; a2=$3; if (a2<0) a2=-a2; if (a1>1e-20 || a2>1e-20) if ((a1>a2 && a1-a2> '"$PREC"'*a1) || (a2>a1 && a2-a1> '"$PREC"'*a2)) print "float diff>'"$PREC"':",a1,a2 }' ${PROG}_tmp_diff.out > ${PROG}_tmp_diff.out2
  if [ -s ${PROG}_tmp_diff.out2 ]
  then
     $CAT ${PROG}_tmp_diff.out2
     echo "FAIL (floating point discrepancies > $PREC): $PROG"
     STATUS=2
     exit
  fi
  echo "PASS (floating point discrepancies <= $PREC): $PROG"
  STATUS=0
  exit
